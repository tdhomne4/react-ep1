npm
 - not node package manager
 - manages all packages, contain repo for all packages
 - package.json is configuration for packages in npm

- dependancy package : parcel - ignite app
- dependancy types : dev (dependancy in developmet) and normal (dependancy in production)

- npm install -D parcel (-D -> dev dependancy)

version 1.2.3 (major.minor.patch(bug fixes))
- caret (^) -> consider update minor and patch versio automatically which is compatible with 
our version but not major version as it can break functionality 1.2.2->1.2.4
- tilde (~) ->  consider update any version for patch and major versio automatically to bug
 fixex like 1.2.3 -> 1.2.3
========================================================================================
#React
- Single page application => it doesn’t reload the page, just render another components
- Client side Routing => doesn’t reload page, just render components when click on any page (Link) 
========================================================================================
Config Driven UI : Whatever the condition coming from backend, UI will change.
- based on the location the UI(color, bg) will change.

========================================================================================

## why To give key={id} in map function ? (for optimization, uniquely identity each loop item)
-by key, every card is unique
- when add new one, react doesn't re-render all card, just add new one at its specific id
- if don't have key,all card is same and re-render all if any chnage happed.
- reactDoc said, don't use indes as key(if api do't have id then we can use)
- because create problem in sorting of card when new item id added reatc get confused

========================================================================================
- Default Export/Import
export default Compenent; - file is exporting by default only one
import Component from "path";

-Named Export/Import
export const name (named export) - to export multiple items from the file.
import {name} from "path";
========================================================================================

##React Hooks
- Normal JS function which give some utility
**useState -> 
- react funtion
- to update variable data  
-> [JSVariable, modifyJsVariable] = useState(default value);
- react keep track of state variable, when change, it triggered the Diff algo and re-render Component
-> why use state ? by using normal js variable we can update variable value but UI doesn’t update, to update UI when variable
change, we need state
========================================================================================
##render- whenever state variable update, react re-render the Component
	-	keep data layer in sync with UI layer

========================================================================================
##Virtual DOM -> representation of actual DOM(HTML Tags) ->ITs object
========================================================================================
#Reconciliation Algorithm (React Fiber-> in React 16) -> DOM Update https://github.com/acdlite/react-fiber-architecture?tab=readme-ov-file
#Diff Algorithm -> 
	-	Calculate difference between Old virtual DOM and new vitual DOM after update is done,
	- then it update the actual DOM on every render cycle.

========================================================================================
#Monolith architecture : 
- all services in one app(DB,API,UI,Authentication code)
- all code written in one language
#Microservice architecture (Single Responsibility Principle) (Seperation of Concerns): 
- all services in seperate app (DB, UI, API)
- all services are run on different port and its connected to url/api or url/backend
- we can write Microservice in different language

========================================================================================
#useEffect(Callback function, dependancy array);
- Callback function call after Component render;
- first body renderes, then useEffect called
- to avoid this behaviour, it has dependancy array, it chnage the behaviour of useEffect.
- if no dependancy array => useEffect called every render
- if empty dependancy array [] => useEffect called only initial render(just once)
- if dependancy array [dependancy array] => useEffect called when dependancy array updated/changed

========================================================================================
##Loader 
- loader is not good
- Shimmer UI 
- A better way to show loading states is to use a shimmer UI. A shimmer UI is a version of the UI that doesn’t contain actual content, but instead mimics the layout and shapes of the content that will eventually appear. It uses a gradient animation that creates a shimmering effect over the placeholders, giving the user a sense of motion and progress.
========================================================================================
#why we can change const variable in useState?

- useState, change the state of variable internally, each render have its internal state and re-render the Component.
- it create new state with new instance of const variable and trigger reconciliation cycle and re-render Component with new state value.
- Thats why DOM manipulation is very fast by react

========================================================================================

#Routing
- createBrowserRouter => recommedned by React, configuration of routes
- RouterProvider => all data router need to pass this components to render app
- children => to make header intact, use other routes as children of app
- <Outlet /> => use in parent route to render all it children routes
- Link => same like ancher tag but it doesn’t reload page , its wrapper over ancher tag which keep track and make not to reload page
- dynamic routing => /path/:id
### Two types : 
#Client side Routing => in react, we have this, all html is loaded at once when we reload the page, when click on about, it just render the about components html,not make network call
$Server Side Routing => when click on any page(about.html), it make a network call, fetch data from that network and display on web page, reload page
-useParams => hook to get the url params

========================================================================================
React Class Component :  About Component
- class ClassName extends React.Compenent{} // know react that its a class component
- Normal javascript classs
- class has render() method which return some piece of JSX.
- When any class found in an component, then instance of a class is created 

-> parent constructor 
-> parent render 
-> first classchild constructor 
-> first classchild render 
-> second classchild constructor 
-> second classchild render 
->Once the DOM is loader, then  
====>>>all above is in render phase of react
-> first classchild componentDidmount() 
-> second classchild componentDidmount() 
->  parent componentDidMount()
====>>>all above is in commit phase of react/ DOM is updated in single BATCH/ API call make in this, 
-> if state change then again render(with API data) is called
-> REACT update DOM again with API data
-> then componentDidUpdate() called
-> when component is removed from DOM -> called ComponentWillUnmount() -> call when we go to another component
->ComponentWillUnmount() will use to clear time internal or localStorage, session
 called in this way. 
- all this is called lifecycle methods of react class.

##componentDidMount() 
- API call is make inside this.
##why ?
- first we render the component and wait for API call. Once API give response we fill the UI with data.
- We don't wait for the API response to render the component. as it will break UI.
- thats why, after componentDidMount we will all API.

##props
- why super(props) is used ? 
		-- when make a class, we extends it from superClass(React.Compenent), it inherit the properties and methods from superClass.
		-- super(props), it pass props from subClass to superClass and call constructor of superClass and make props available in subClass by using this (this.props.name) 

##State
- best place to define state and get props is in the constructor.
- we can make state using "this.state" keyword.
- state in this is whole object for all state variable in class component.
- this.setState({}) // use to update state variable in class component

========================================================================================
optimization ofApp : 

#Single Responsibility Principle : 
- use and create custom hooks for each functionality as then component will only resposible for displaying data

#Bundling
- it bundle all files and make a one js file but we need to keep checking the size of this one js file
- to make this, we can make smaller bundles of this files called => 
		-	Chunking, 
		- Code Splitting, 
		- Lazy loading, 
		- Dynamic Bundling
		- make smalled bundles for different major component

#- How to cretae seperate bundles : 
	- create on demand loading, when click on that page then only it load 
	- use Lazy() function provided by react, and import seperate bundle component in lazy function
	- const Grocery = lazy(() => import(path_of_Grocery_component))
	- suspense error for Route.provider =>  to fix this, use Suspense component by react and wrap lazy component in it and all fallback parameter to show loading state until Grocery loads.
	- this error because Grocery code is not in main bundle, to load another bundle it take some time and show error